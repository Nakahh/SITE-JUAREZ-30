generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Papel {
  ADMIN
  CORRETOR
  ASSISTENTE
  CLIENTE
}

model User {
  id            String    @default(uuid()) @id
  email         String    @unique
  password      String?   // Para login com credenciais
  nome          String?   // Nome do usuário, mapeado para 'name' na sessão NextAuth
  papel         Papel     @default(CLIENTE) // Papel personalizado para controle de acesso
  emailVerified DateTime? // Para provedores OAuth
  image         String?   // URL da imagem do perfil para provedores OAuth
  phone         String?   // Novo campo para telefone do usuário
  address       String?   // Novo campo para endereço do usuário
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  savedSearches SavedSearch[] // Relação com buscas salvas
  testimonials  Testimonial[] // Relação com depoimentos
  propertyReviews PropertyReview[] // Relação com avaliações de imóveis
  articleComments ArticleComment[] // Relação com comentários de artigos
  properties    Property[] // Imóveis atribuídos a este corretor
  favoriteProperties FavoriteProperty[] // Relação com favoritos
  visits        Visit[] @relation("UserVisits") // Relação com visitas (se o cliente for um User)
  
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Property {
  id          String    @default(uuid()) @id
  titulo      String
  descricao   String?
  preco       Float
  tipo        String
  quartos     Int
  area        Float
  localizacao String
  status      String    @default("Disponível")
  imageUrls   String[]  // URLs de imagens
  comodidades String[]  // Novo campo para comodidades
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  favorites   FavoriteProperty[] // Relação com favoritos
  visits      Visit[] // Relação com visitas
  agentId     String?   // ID do corretor responsável pelo imóvel
  agent       User?     @relation(fields: [agentId], references: [id]) // Relação com o corretor
  reviews     PropertyReview[] // Relação com avaliações de imóveis

  @@map("properties")
}

model Client {
  id        String   @default(uuid()) @id
  nome      String
  email     String   @unique
  telefone  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  visits    Visit[] // Relação com visitas

  @@map("clients") // Usado para leads
}

model Article {
  id        String   @default(uuid()) @id
  titulo    String
  slug      String   @unique
  conteudo  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  comments  ArticleComment[] // Relação com comentários de artigos

  @@map("articles")
}

model Message {
  id        String   @default(uuid()) @id
  conteudo  String
  createdAt DateTime @default(now())

  @@map("messages")
}

model Visit {
  id          String   @default(uuid()) @id
  propertyId  String   // ID do imóvel agendado
  clientId    String   // ID do cliente que agendou a visita
  userId      String?  // NOVO: ID do usuário registrado que agendou/está associado à visita
  dataHora    DateTime // Data e hora da visita
  status      String   @default("Pendente") // Pendente, Confirmada, Cancelada, Realizada
  createdAt   DateTime @default(now())
  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade) // Relação com o cliente
  user        User?    @relation("UserVisits", fields: [userId], references: [id], onDelete: Cascade) // NOVO: Relação com o usuário

  @@map("visits")
}

model FinancialRecord {
  id        String   @default(uuid()) @id
  descricao String?
  valor     Float
  tipo      String   // "Receita" ou "Despesa"
  data      DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("financial_records")
}

model FavoriteProperty {
  id         String   @default(uuid()) @id
  userId     String   // ID do usuário que favoritou
  propertyId String   // ID do imóvel favoritado
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade) // NOVO: Relação com o usuário
  createdAt  DateTime @default(now())

  @@unique([userId, propertyId]) // Garante que um usuário não favorite o mesmo imóvel duas vezes
  @@map("favorite_properties")
}

model NewsletterSubscription {
  id        String   @default(uuid()) @id
  email     String   @unique
  createdAt DateTime @default(now())

  @@map("newsletter_subscriptions")
}

model SavedSearch {
  id            String    @default(uuid()) @id
  userId        String
  searchParams  Json      // Armazena os parâmetros de busca (e.g., { tipo: "Casa", minPreco: 200000 })
  lastNotifiedAt DateTime? // Última vez que uma notificação foi enviada para esta busca
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("saved_searches")
}

model Testimonial {
  id        String    @default(uuid()) @id
  authorId  String?   // Opcional: se o depoimento for de um usuário registrado
  authorName String    // Nome do autor (pode ser de um usuário ou visitante)
  content   String
  rating    Int       @default(5) // Avaliação de 1 a 5 estrelas
  approved  Boolean   @default(false) // Depoimentos precisam ser aprovados por um admin
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  author User? @relation(fields: [authorId], references: [id], onDelete: SetNull)

  @@map("testimonials")
}

model PropertyReview {
  id         String   @id @default(uuid())
  rating     Int      @default(0) @db.SmallInt
  comment    String?  @db.Text
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  propertyId String
  userId     String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([propertyId])
  @@index([userId])
}

model ArticleComment {
  id        String   @id @default(uuid())
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  articleId String
  userId    String
  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([articleId])
  @@index([userId])
}
